import {parseMap, findMinPath, findMinPathRec} from "../src/d20";
import "jasmine";

describe("star1 examples", function() {
  const cases: [number, string][] = [
    [23,
     "         A           \n" +
     "         A           \n" +
     "  #######.#########  \n" +
     "  #######.........#  \n" +
     "  #######.#######.#  \n" +
     "  #######.#######.#  \n" +
     "  #######.#######.#  \n" +
     "  #####  B    ###.#  \n" +
     "BC...##  C    ###.#  \n" +
     "  ##.##       ###.#  \n" +
     "  ##...DE  F  ###.#  \n" +
     "  #####    G  ###.#  \n" +
     "  #########.#####.#  \n" +
     "DE..#######...###.#  \n" +
     "  #.#########.###.#  \n" +
     "FG..#########.....#  \n" +
     "  ###########.#####  \n" +
     "             Z       \n" +
     "             Z       \n",
    ],
    [58,
     "                   A               \n" +
     "                   A               \n" +
     "  #################.#############  \n" +
     "  #.#...#...................#.#.#  \n" +
     "  #.#.#.###.###.###.#########.#.#  \n" +
     "  #.#.#.......#...#.....#.#.#...#  \n" +
     "  #.#########.###.#####.#.#.###.#  \n" +
     "  #.............#.#.....#.......#  \n" +
     "  ###.###########.###.#####.#.#.#  \n" +
     "  #.....#        A   C    #.#.#.#  \n" +
     "  #######        S   P    #####.#  \n" +
     "  #.#...#                 #......VT\n" +
     "  #.#.#.#                 #.#####  \n" +
     "  #...#.#               YN....#.#  \n" +
     "  #.###.#                 #####.#  \n" +
     "DI....#.#                 #.....#  \n" +
     "  #####.#                 #.###.#  \n" +
     "ZZ......#               QG....#..AS\n" +
     "  ###.###                 #######  \n" +
     "JO..#.#.#                 #.....#  \n" +
     "  #.#.#.#                 ###.#.#  \n" +
     "  #...#..DI             BU....#..LF\n" +
     "  #####.#                 #.#####  \n" +
     "YN......#               VT..#....QG\n" +
     "  #.###.#                 #.###.#  \n" +
     "  #.#...#                 #.....#  \n" +
     "  ###.###    J L     J    #.#.###  \n" +
     "  #.....#    O F     P    #.#...#  \n" +
     "  #.###.#####.#.#####.#####.###.#  \n" +
     "  #...#.#.#...#.....#.....#.#...#  \n" +
     "  #.#####.###.###.#.#.#########.#  \n" +
     "  #...#.#.....#...#.#.#.#.....#.#  \n" +
     "  #.###.#####.###.###.#.#.#######  \n" +
     "  #.#.........#...#.............#  \n" +
     "  #########.###.###.#############  \n" +
     "           B   J   C               \n" +
     "           U   P   P               \n",
    ]
  ];

  for (const [minRoute, input] of cases) {
    it (`Min route is ${minRoute} steps`, function() {
      const maze = parseMap(input);

      expect(findMinPath(maze, "AA", "ZZ")).toEqual(minRoute);
    });
  }
});

describe("star2 examples", function() {
  const cases: [number, string][] = [
    [26,
     "         A           \n" +
     "         A           \n" +
     "  #######.#########  \n" +
     "  #######.........#  \n" +
     "  #######.#######.#  \n" +
     "  #######.#######.#  \n" +
     "  #######.#######.#  \n" +
     "  #####  B    ###.#  \n" +
     "BC...##  C    ###.#  \n" +
     "  ##.##       ###.#  \n" +
     "  ##...DE  F  ###.#  \n" +
     "  #####    G  ###.#  \n" +
     "  #########.#####.#  \n" +
     "DE..#######...###.#  \n" +
     "  #.#########.###.#  \n" +
     "FG..#########.....#  \n" +
     "  ###########.#####  \n" +
     "             Z       \n" +
     "             Z       \n",
    ],
    // [Infinity,     // Runs indefinitly
    //  "                   A               \n" +
    //  "                   A               \n" +
    //  "  #################.#############  \n" +
    //  "  #.#...#...................#.#.#  \n" +
    //  "  #.#.#.###.###.###.#########.#.#  \n" +
    //  "  #.#.#.......#...#.....#.#.#...#  \n" +
    //  "  #.#########.###.#####.#.#.###.#  \n" +
    //  "  #.............#.#.....#.......#  \n" +
    //  "  ###.###########.###.#####.#.#.#  \n" +
    //  "  #.....#        A   C    #.#.#.#  \n" +
    //  "  #######        S   P    #####.#  \n" +
    //  "  #.#...#                 #......VT\n" +
    //  "  #.#.#.#                 #.#####  \n" +
    //  "  #...#.#               YN....#.#  \n" +
    //  "  #.###.#                 #####.#  \n" +
    //  "DI....#.#                 #.....#  \n" +
    //  "  #####.#                 #.###.#  \n" +
    //  "ZZ......#               QG....#..AS\n" +
    //  "  ###.###                 #######  \n" +
    //  "JO..#.#.#                 #.....#  \n" +
    //  "  #.#.#.#                 ###.#.#  \n" +
    //  "  #...#..DI             BU....#..LF\n" +
    //  "  #####.#                 #.#####  \n" +
    //  "YN......#               VT..#....QG\n" +
    //  "  #.###.#                 #.###.#  \n" +
    //  "  #.#...#                 #.....#  \n" +
    //  "  ###.###    J L     J    #.#.###  \n" +
    //  "  #.....#    O F     P    #.#...#  \n" +
    //  "  #.###.#####.#.#####.#####.###.#  \n" +
    //  "  #...#.#.#...#.....#.....#.#...#  \n" +
    //  "  #.#####.###.###.#.#.#########.#  \n" +
    //  "  #...#.#.....#...#.#.#.#.....#.#  \n" +
    //  "  #.###.#####.###.###.#.#.#######  \n" +
    //  "  #.#.........#...#.............#  \n" +
    //  "  #########.###.###.#############  \n" +
    //  "           B   J   C               \n" +
    //  "           U   P   P               \n",
    // ]
    [396,
     "             Z L X W       C                 \n" +
     "             Z P Q B       K                 \n" +
     "  ###########.#.#.#.#######.###############  \n" +
     "  #...#.......#.#.......#.#.......#.#.#...#  \n" +
     "  ###.#.#.#.#.#.#.#.###.#.#.#######.#.#.###  \n" +
     "  #.#...#.#.#...#.#.#...#...#...#.#.......#  \n" +
     "  #.###.#######.###.###.#.###.###.#.#######  \n" +
     "  #...#.......#.#...#...#.............#...#  \n" +
     "  #.#########.#######.#.#######.#######.###  \n" +
     "  #...#.#    F       R I       Z    #.#.#.#  \n" +
     "  #.###.#    D       E C       H    #.#.#.#  \n" +
     "  #.#...#                           #...#.#  \n" +
     "  #.###.#                           #.###.#  \n" +
     "  #.#....OA                       WB..#.#..ZH\n" +
     "  #.###.#                           #.#.#.#  \n" +
     "CJ......#                           #.....#  \n" +
     "  #######                           #######  \n" +
     "  #.#....CK                         #......IC\n" +
     "  #.###.#                           #.###.#  \n" +
     "  #.....#                           #...#.#  \n" +
     "  ###.###                           #.#.#.#  \n" +
     "XF....#.#                         RF..#.#.#  \n" +
     "  #####.#                           #######  \n" +
     "  #......CJ                       NM..#...#  \n" +
     "  ###.#.#                           #.###.#  \n" +
     "RE....#.#                           #......RF\n" +
     "  ###.###        X   X       L      #.#.#.#  \n" +
     "  #.....#        F   Q       P      #.#.#.#  \n" +
     "  ###.###########.###.#######.#########.###  \n" +
     "  #.....#...#.....#.......#...#.....#.#...#  \n" +
     "  #####.#.###.#######.#######.###.###.#.#.#  \n" +
     "  #.......#.......#.#.#.#.#...#...#...#.#.#  \n" +
     "  #####.###.#####.#.#.#.#.###.###.#.###.###  \n" +
     "  #.......#.....#.#...#...............#...#  \n" +
     "  #############.#.#.###.###################  \n" +
     "               A O F   N                     \n" +
     "               A A D   M                     \n",
    ],
  ];

  for (const [minRoute, input] of cases) {
    it (`Min route is ${minRoute} steps`, function() {
      const maze = parseMap(input);

      expect(findMinPathRec(maze, "AA", "ZZ")).toEqual(minRoute);
    });
  }

});
